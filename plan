UMHC Treasurer: View-Only Access Implementation Plan

Goal
- Add a second passkey that grants view-only access on the same app URL.
- Move opening balance config from `B1/B2` to `C1/C2`.
- Use `A1/A2` for normal passkey and `B1/B2` for view-only passkey.
- Preserve existing architecture: Action -> Service -> State -> UI Update.

Design Constraints (from `code.txt`)
- Keep UI components dumb: they render state and dispatch actions.
- Keep permission/auth logic in service layers, not scattered in components.
- Keep backend controller (`Code.gs`) as router/traffic cop with standardized responses.
- Keep state (`currentUser`) as the single source of truth for frontend mode.

1) Backend Config Layout + Migration
- Files: `google-apps-script/Config.gs`, `google-apps-script/Service_Sheet.gs`
- Update config constants:
  - `API_KEY_TITLE_CELL = A1`, `API_KEY_CELL = A2` (normal/full-access passkey)
  - `VIEW_ONLY_API_KEY_TITLE_CELL = B1`, `VIEW_ONLY_API_KEY_CELL = B2`
  - `OPENING_BALANCE_TITLE_CELL = C1`, `OPENING_BALANCE_CELL = C2`
  - New title constant: `VIEW_ONLY_API_KEY_TITLE = "View Only Passkey"`
- Add one-time migration logic in `_getConfigSheet()`:
  - Detect legacy layout (`B1 == "Initial Balance"`).
  - Move legacy balance value from `B2` to `C2` if `C2` is empty.
  - Write new labels to `A1`, `B1`, `C1`.
  - Clear legacy `B2` after successful move.
- Keep migration idempotent so repeated runs do not overwrite valid new config.

2) Backend Auth: Dual Passkeys + Role-Aware Sessions
- Files: `google-apps-script/Service_Auth.gs`, `google-apps-script/Service_Session.gs`, `google-apps-script/Code.gs`
- Extend auth service to read both passkeys from config:
  - Normal passkey (admin/full-access)
  - View-only passkey
- Change login verification flow:
  - For `action=login`, verify signature against both secrets.
  - Determine role from which secret matched (`admin` or `viewer`).
- Extend session payload in cache:
  - Store `{ sessionKey, role }` (session role is authoritative after login).
- Return role in auth responses:
  - `login` response includes `role`.
  - `ping` response includes `role` for session restore after refresh.

3) Backend Authorization (Server-Side Enforcement)
- File: `google-apps-script/Code.gs` (or helper in `Service_Auth.gs`)
- Define action permission map:
  - Read actions: `ping`, `getData`, `getAppData`, `getOpeningBalance`, `getSplitGroup`, `getSplitHistory`
  - Write actions: `saveData`, `addTag`, `updateExpenses`, `deleteTag`, `renameTag`, `processTagOperations`, `saveOpeningBalance`, `splitTransaction`, `revertSplit`, `editSplit`
- Enforce:
  - `admin` can call all actions.
  - `viewer` can call read actions only.
- Return consistent forbidden response for blocked write attempts (do not clear session).
- Keep unauthorized vs forbidden distinct:
  - `Unauthorized` = invalid/expired signature/session
  - `Forbidden` = valid viewer session attempting mutation

4) Frontend Auth State + Capability Model
- Files: `src/services/auth.service.js`, `src/services/api.service.js`, `src/core/state.js` (state shape), `src/features/login/login.component.js`
- On login success, store:
  - `currentUser = { loggedIn: true, role, canEdit: role === "admin" }`
- On `AuthService.init()`, use `ping` role to restore `currentUser` accurately.
- Keep passkeys out of state (existing behavior remains).
- Add centralized client guard in `ApiService` for mutating methods:
  - If `!canEdit`, reject early with a clear view-only message.
  - Backend remains final authority (defense in depth).
- Update login text from “API Key” to “Passkey” to match config terminology.

5) UI Read-Only Behavior (UX Layer)
- Files: `src/App.js`, `src/features/upload/upload.component.js`, `src/features/transactions/*`, `src/features/tags/*`, `src/features/settings/settings.component.js`
- Add read-only mode indicator (header badge/banner) based on `currentUser.canEdit`.
- Upload:
  - Disable upload action or show a read-only notice.
- Transactions:
  - Disable inline tag editing (`+`, remove, tag selector).
  - Hide/disable save, bulk tagging, add manual transaction, split create/edit/revert.
  - Keep filters/search/table viewing.
- Tags:
  - Keep list/details viewing.
  - Hide/disable edit mode controls and mutation actions (add/rename/delete/save, trip-type/status changes, “Add Transactions”, “Add Trip/Events”).
- Settings:
  - Keep balance display and calculations visible.
  - Hide/disable opening balance edit for view-only users.
  - Keep local-only preferences (e.g., accessibility toggle) enabled.

6) Documentation Updates
- Files: `google-apps-script/README.md`, `README.md` (feature summary)
- Update Config sheet setup:
  - `A1/A2`: Passkey
  - `B1/B2`: View Only Passkey
  - `C1/C2`: Initial Balance
- Document role behavior and permission boundaries.
- Add migration note for existing deployments using legacy `B1/B2` balance.

7) Validation Plan
- Legacy migration test:
  - Existing sheet with old layout auto-migrates balance to `C2`.
- Admin login test:
  - All write flows still work (upload, tags, transactions edits, splits, opening balance save).
- Viewer login test:
  - Can view all read data.
  - All write UI actions are disabled/hidden.
  - Forced write API calls return forbidden.
- Session restore test:
  - Refresh keeps role via `ping`.
- Regression test:
  - Existing read-only pages (dashboard/analysis) behave unchanged.

Implementation Order (recommended)
1. Backend config constants + migration.
2. Backend dual-key login + role-aware session + authorization map.
3. Frontend auth/session role wiring.
4. Central client-side mutation guard in `ApiService`.
5. UI read-only gating in feature components.
6. Docs + end-to-end manual verification.

Key Risks and Mitigations
- Risk: Breaking existing sheets due to config move.
  - Mitigation: Idempotent migration logic in `_getConfigSheet()`.
- Risk: UI-only lockout without backend protection.
  - Mitigation: server-side permission checks for all write actions.
- Risk: Role loss after refresh.
  - Mitigation: include role in `ping` and restore `currentUser` from it.
